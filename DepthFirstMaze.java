package myMaze;

import java.util.ArrayList;
import java.util.Random;
import java.util.Stack;


public class DepthFirstMaze {	
	
	int num;
	//?????§³
	
	private int start = 0;
	private int end;
	//??????????????????????
	
	Cell[] cells;
	
	final static int UP = 0;
	final static int RIGHT = 1;
	final static int DOWN = 2;
	final static int LEFT = 3;
	//??????????????????

	
	public DepthFirstMaze(int cellsNum) {
		num = cellsNum;
		cells = new Cell[num*num];
		//????num*num???????
		
		end = num*num - 1;
		
		buildCells();
		dig();
		
		//??????¡¤,??????????????????§³
		for(int i = 0; i < num/5; i++) {
			getMoreSolution();
		}
	}
	
	
	
	private void buildCells() {
		for(int i = 0; i < cells.length; i++) {//???????????Cell????
			cells[i] = new Cell();
		}
		
//		cells[0].sides[LEFT] = cells[num*num - 1].sides[RIGHT] 
//							 = Cell.PATH;
		//???????????????????????????????????????????¡¤
		cells[0].isDug = true;
		//??????????????????????
	}
	
	
	//??¡¤
	private void dig() {
		Stack<Cell> extendableCell = new Stack<>();	//????›¥???????????
		
		int location = 0;
		
		extendableCell.push(cells[location]);//?????????
		
		Cell peek;
		
		while(!extendableCell.isEmpty()) {//????????????§á??????????????
			
			peek = extendableCell.peek();//???????????????peek
			
			location = indexOf(peek);//???¦Ë????????????cells???????¦Ë??
			
			if(extendable(location)) {//??????¦Ë???????
				location = buildPath(location);//????????¦Ë??
				if(extendable(location)) {//?????????¦Ë???????
					extendableCell.push(cells[location]);//????¦Ë????????
				}
			}
			else {
				extendableCell.pop();//??????????????????????????
			}
			
		}
		
	}
	
	
	
	//????c???????§Ö??¡À?
	private int indexOf(Cell c) {
		for(int i = 0; i < cells.length; i++) {
			if(c == cells[i]) {
				return i;
			}
		}
		
		return -1;
	}
	
	
	
	//?§Ø???¦Ë??????????
	private boolean extendable(int location) {
		if(!isBorder(location, UP) && !dugCell(location, UP)) {
			return true;
		}
		if(!isBorder(location, RIGHT) && !dugCell(location, RIGHT)) {
			return true;
		}
		if(!isBorder(location, DOWN) && !dugCell(location, DOWN)) {
			return true;
		}
		if(!isBorder(location, LEFT) && !dugCell(location, LEFT)) {
			return true;
		}else {//??????¦Ë?????????????????????????¡Â????????????????????
			//?????¦Ë????????????
			return false;
		}
	}
	
	
	public class Cell{
		boolean[] sides;
		boolean isDug = false;
		//??????¦Ä???????
		
		boolean passedBy = false;
		
		final static boolean PATH = true;
		final static boolean WALL = false;
		
		public Cell() {
			sides = new boolean[4];
			
			for (int i = 0; i < sides.length; i++) {//??????›ö???
				sides[i] = WALL;
			}
		}
	}
	
	
	//?§Ø?¡Â??????????
	private boolean isBorder(int location, int dir) {
			
		if(location < num && dir == UP) {
			return true;
		}//??????¦Ë???????????????????????????????????????????
		
		if(location%num == 0 && dir == LEFT) {
			return true;
		}//??????¦Ë??????????????????????????????????????????
		
		if(location%num == (num-1) && dir == RIGHT) {
			return true;
		}//??????¦Ë????????????????????????????????????????????
		
		if(location > (num*(num-1)-1) && dir == DOWN) {
			return true;
		}//??????¦Ë????????????????????????????????????????????

		return false;
	}
	
	
	//?§Ø?????¦Ë????????????????????
	private boolean dugCell(int location, int dir) {
		
		location = relocate(location, dir);
		
		return cells[location].isDug;
	}
	
	
	//?¡¤?????????????????????????¡¤???¦Ë??
	private int buildPath(int location) {
		int dir = new Random().nextInt(4);
		if(isBorder(location, dir) || dugCell(location, dir)) {
			//????¡Â????????????????????????????
			return location;
		}
		
		
		int opDir;
		//dir???????
		
		cells[location].sides[dir] = Cell.PATH;
		//??dir???????¡¤
		
		location = relocate(location, dir);
		opDir = dir+2;
		if(opDir > LEFT) {
			opDir -= 4;
		}
		cells[location].sides[opDir] = Cell.PATH;
		cells[location].isDug = true;
		//??????¦Ë?¨²?????¦Ë??location????????¦Ë????????¦Ë?????????¡¤??
		//??¦Ë????????????????
		
		return location;
	}
	
	
	//??????¦Ë???¡À?
	private int relocate(int location, int dir) {
		switch (dir) {
		case UP: 
			location -= num;
			break;
		case RIGHT: 
			location += 1;
			break;
		case DOWN: 
			location += num;
			break;
		case LEFT: 
			location -= 1;
			break;
		default:
			throw new IllegalArgumentException("Unexpected value: " + dir);
		}
		
		return location;
	}
	
	
	//?????????????¡¤???¡¤
	public Stack<Cell> getSolution() {
		Stack<Cell> solution = new Stack<>();
		//????›¥¡¤??
		
		int location = start;
		//???¦Ë???????
		
		solution.push(cells[location]);
		cells[location].passedBy = true;
		//???????????
		
		Cell peek;
		
		while(location != end) {//??¦Ë?¨°???????????
			int dir = new Random().nextInt(4);
			
			peek = solution.peek();
			
			if(deadEnd(location)) {//??????¦Ë??????¡¤
				solution.pop();//?????¦Ë????????
				
				if(solution.isEmpty()) {//???¡¤?????
					break;
				}
				
				location = indexOf(solution.peek());//??????¦Ë???¡À?
				continue;
			}
			
			
			if(peek.sides[dir] == Cell.WALL ||
			  isTheCellPassedBy(location, dir)) {
				//?????????¡Â?????????????????????????????
				continue;
			}
			
			location = relocate(location, dir);
			//????¦Ë??
			
			cells[location].passedBy = true;
			solution.push(cells[location]);
			//????¦Ë?????????¦²?????????
		}
		
		return solution;
	}
	
	
	//???????¡¤????????
//	@SuppressWarnings("unchecked")
	public ArrayList<Stack<Cell>> walkOver() {
		ArrayList<Stack<Cell>> allPath = new ArrayList<>();
		//????¡¤??
		Stack<Cell> temp = new Stack<>();
		//???¡¤??
		
		byte pathNum = 0;
		while(allPath.size() < num/5 + 1) {
			cleanPath();
			temp = getSolution();
			
			if(!isWalkedPath(allPath, temp)) {
				allPath.add(temp);
			}
			pathNum++;
			
			if(pathNum >= num) {
				break;
			}
		}
		
		
		return allPath;
	}
	
	//??????????????????
	private void cleanPath() {
		for(int i = 0; i < cells.length; i++) {
			cells[i].passedBy = false;
		}
	}
	
	
	//?§Ø?¡¤??path????????????allPath
	private boolean isWalkedPath(ArrayList<Stack<Cell>> allPath, Stack<Cell> path) {
		if(allPath.size() == 0) {//???¡¤??????
			return false;
		}
		
		Stack<Cell> temp;
		boolean mark;
		
		for(int i = 0; i < allPath.size(); i++) {
			mark = true;
			temp = allPath.get(i);
			if(temp.size() == path.size()) {//??§³?????????????¡¤??
				for(int j = 0; j < temp.size(); j++) {
					if(temp.get(j) != path.get(j)) {//?????????????????????????¡¤
						mark = false;
						break;
					}
				}
				
				if(mark) {//????????????mark??¦Ä??????false?????temp??path??????¡¤
					return true;
				}
			}
		}
		
		return false;
	}
	
	
	
	//?§Ø?????????¡¤
	private boolean deadEnd(int location) {
		if(cells[location].sides[UP] == Cell.WALL ||
		   isTheCellPassedBy(location, UP)) {
			
			if(cells[location].sides[RIGHT] == Cell.WALL ||
					isTheCellPassedBy(location, RIGHT)) {
				
				if(cells[location].sides[DOWN] == Cell.WALL ||
						isTheCellPassedBy(location, DOWN)) {

					if(cells[location].sides[LEFT] == Cell.WALL ||
							isTheCellPassedBy(location, LEFT)) {
						return true;
					}//??????¦Ë???????????????????¡¤?????¦Ë?????¡¤
				}
			}
		}
		
		return false;
	}
	
	
	
	//???????¡Â?????????????????passedBy???
	private boolean isTheCellPassedBy(int location, int dir) {
		
		location = relocate(location, dir);
		
		return cells[location].passedBy;
	}


	
	
	//??????????
	public void setStart(int start) {
		this.start = start;
	}
	public void setEnd(int end) {
		this.end = end;
	}



	
	
	//?????????
	public int getStart() {
		return start;
	}
	public int getEnd() {
		return end;
	}
	
	
	
	//????????¡¤
	private void getMoreSolution() {
		int location = new Random().nextInt(num*num - 1);
		int dir = new Random().nextInt(4);
		
		while(isBorder(location, dir) || cells[location].sides[dir] == Cell.PATH) {
			location = new Random().nextInt(num*num - 1);
			dir = new Random().nextInt(4);
		};
		
		int opDir;
		//dir???????
		
		cells[location].sides[dir] = Cell.PATH;
		//??dir???????¡¤
		
		location = relocate(location, dir);
		opDir = dir+2;
		if(opDir > LEFT) {
			opDir -= 4;
		}
		cells[location].sides[opDir] = Cell.PATH;
		
	}
	
	
}
